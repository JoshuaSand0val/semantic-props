function e(e){const t=["--2xs-breakpoint","--xs-breakpoint","--sm-breakpoint","--md-breakpoint","--lg-breakpoint","--xl-breakpoint","--2xl-breakpoint","--3xl-breakpoint"];let o;new ResizeObserver((()=>{clearTimeout(o),o=setTimeout((()=>{const o=e.style.minInlineSize,n=getComputedStyle(e).getPropertyValue("inline-size");for(const o of t)e.style.minInlineSize=`min(var(${o}) - ${n}, ${n})`,"0px"!==getComputedStyle(e).getPropertyValue("min-inline-size")?e.classList.remove(o):e.classList.add(o);e.style.minInlineSize=o}),10)})).observe(e)}function t(e){const t=matchMedia("(prefers-color-scheme: dark)"),o=(e.parentElement||document.documentElement).closest(".--semantic:is(.--light-color, .--dark-color)"),n=()=>{const n=o?o.classList.contains("--dark-color"):t.matches;e.classList.remove(n?"--light-color":"--dark-color"),e.classList.add(n?"--dark-color":"--light-color")};t.addEventListener("change",n),n()}
/**
 * Adds custom property classes to all Semantic Props elements.
 * @type {Function}
 * @preserve
 */function o(){const o=o=>{for(const n of[o,...o.getElementsByTagName("*")])n.matches(".--semantic")&&(e(n),t(n))};let n;o(document.documentElement);new MutationObserver((e=>{clearTimeout(n),n=setTimeout((()=>{for(const t of e)if(t.oldValue&&t.oldValue.includes("--semantic"))for(const e of t.target.children)o(e);else o(t.target)}),10)})).observe(document.documentElement,{subtree:!0,childList:!0,attributeFilter:["class"],attributeOldValue:!0})}"undefined"!=typeof window&&addEventListener("DOMContentLoaded",o);export{o as default};
